package Puzzle_Lab.Routes; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.stream.Collectors; import Puzzle_Lab.ResponseBody; import Puzzle_Lab.TokenService; import Puzzle_Lab.Entities.Puzzle; import Puzzle_Lab.Entities.User; import Puzzle_Lab.Enums.Status; import io.quarkus.panache.common.Sort; import jakarta.annotation.security.RolesAllowed; import jakarta.enterprise.context.ApplicationScoped; 
import jakarta.transaction.Transactional; 
import jakarta.ws.rs.*; import jakarta.ws.rs.core.*; @ApplicationScoped @Path("/puzzles") public class PuzzleResource { @GET @Path("/{id}") @Produces(MediaType.APPLICATION_JSON) public Response getPuzzle(@PathParam("id") Long id, @Context SecurityContext ctx, @QueryParam("mode") String mode) { if (mode == null || !mode.equals("edit") && !mode.equals("play")) { 
	return new ResponseBody(Response.Status.BAD_REQUEST).addMessage("A 'mode' query parameter must be set to either 'play' or 'edit'.") .build(); } Puzzle puzzle = Puzzle.find("id", id).firstResult(); if (puzzle == null) { return new ResponseBody(Response.Status.NOT_FOUND) .addMessage("Unable to find a puzzle with that ID.") .build(); } // Playable if the puzzle is public or if they have full access if (mode.equals("play") && (hasFullAccess(id, ctx) || puzzle.getStatus().equals(Status.PUBLIC) || puzzle.getStatus().equals(Status.UNLISTED))) { return new ResponseBody(Response.Status.OK) .addMessage("Successfully obtained puzzle.") .addObject("puzzle", puzzle.getEmptyDTO()) .build(); // Editable only if they have full access } else if (mode.equals("edit") && hasFullAccess(id, ctx)) { return new ResponseBody(Response.Status.OK) .addMessage("Successfully obtained puzzle.") .addObject("puzzle", puzzle.getFullDTO()) .build(); } else { return new ResponseBody(Response.Status.NOT_FOUND) .addMessage("Unable to find a puzzle with that ID.") .build(); } } @Transactional @DELETE @Path("/{id}") @RolesAllowed({"USER"}) @Produces(MediaType.APPLICATION_JSON) public Response deletePuzzle(@PathParam("id") Long id, @Context SecurityContext ctx) { Puzzle puzzle = Puzzle.find("id", id).firstResult(); if (puzzle == null || !hasFullAccess(id, ctx)) { return new ResponseBody(Response.Status.NOT_FOUND) .addMessage("Unable to find a puzzle with that ID.") .build(); } puzzle.delete(); return new ResponseBody(Response.Status.OK) .addMessage("Successfully deleted the puzzle.") .build(); } @Transactional @PUT @Path("/{id}") @RolesAllowed({"USER"}) @Produces(MediaType.APPLICATION_JSON) public Response updatePuzzle(@PathParam("id") Long id, @Context SecurityContext ctx, Map<String, String> body) { Puzzle puzzle = Puzzle.find("id", id).firstResult(); if (puzzle == null || !hasFullAccess(id, ctx)) { return new ResponseBody(Response.Status.NOT_FOUND) .addMessage("Unable to find a puzzle with that ID.") .build(); } List<String> invalidFields = new ArrayList<>(); for (String key : body.keySet()) { String value = body.get(key); switch (key) { case "title" -> puzzle.setTitle(value); case "description" -> puzzle.setDescription(value); case "status" -> { boolean isValidStatus = Arrays.stream(Status.values()).anyMatch(status -> status.name().equals(value)); if (!isValidStatus) invalidFields.add(key); else puzzle.setStatus(Status.valueOf(body.get(key))); } case "hints" -> puzzle.setHints(value); case "cells" -> puzzle.setCells(value); default -> invalidFields.add(key); } } puzzle.setLastUpdated(); puzzle.persist(); return new ResponseBody(Response.Status.OK) .addMessage(body.keySet().size() - invalidFields.size() + " fields were updated.") .addObject("invalidFields", invalidFields) .addObject("puzzle", puzzle.getFullDTO()) .build(); } @Transactional @POST @RolesAllowed({"USER"}) @Produces(MediaType.APPLICATION_JSON) public Response createPuzzle(@Context SecurityContext ctx, Map<String, String> body) { String title = body.get("title"); String description = body.get("description"); String cellsJson = body.get("cells"); String hintsJson = body.get("hints"); String statusString = body.get("status"); if (title == null || title.isBlank()) { return new ResponseBody(Response.Status.BAD_REQUEST) .addMessage("Missing a 'title' field.") .build(); } if (cellsJson == null) { return new ResponseBody(Response.Status.BAD_REQUEST) .addMessage("Missing a 'cells' field.") .build(); } if (hintsJson == null) { return new ResponseBody(Response.Status.BAD_REQUEST) .addMessage("Missing a 'hints' field.") .build(); } boolean isValidStatus = Arrays.stream(Status.values()).anyMatch(status -> status.name().equals(statusString)); if (!isValidStatus) { return new ResponseBody(Response.Status.BAD_REQUEST) .addMessage("Invalid 'status' field.") .build(); } Long userID = Long.valueOf(ctx.getUserPrincipal().getName()); User creator = User.getUser(userID); Puzzle puzzle = new Puzzle(creator, title, description, cellsJson, hintsJson, Status.valueOf(statusString)); puzzle.persist(); return new ResponseBody(Response.Status.OK) .addMessage("Successfully created a puzzle!") .addObject("puzzle", puzzle.getFullDTO()) .build(); } @GET @Produces(MediaType.APPLICATION_JSON) public Response getAllPuzzles(@QueryParam("limit") Integer limit, @QueryParam("page") Integer page) { if (limit == null) limit = 12; else limit = Math.max(Math.min(limit, 100), 0); // Max 100, min 0 if (page == null) page = 0; else page = Math.max(page, 0); // min 0 List<Puzzle> puzzles = Puzzle.find("status = ?1", Sort.by("lastUpdated").descending(), Status.PUBLIC).page(page, limit).list(); List<Object> puzzleDTOs = puzzles.stream().map(Puzzle::getEmptyDTO).collect(Collectors.toList()); return new ResponseBody(Response.Status.OK) .addMessage("Successfully got " + puzzles.size() + " puzzles.") .addObject("puzzles", puzzleDTOs) .build(); } @POST @Path("/{id}/validate") @Produces(MediaType.APPLICATION_JSON) @Transactional public Response validatePuzzle(@PathParam("id") Long id, Map<String, String> body, @Context SecurityContext ctx){ if (body.get("cells") == null) { return new ResponseBody(Response.Status.BAD_REQUEST) .addMessage("Please specify a 'cells' query parameter.") .build(); } Puzzle puzzle = Puzzle.find("id", id).firstResult(); if (puzzle == null) { return new ResponseBody(Response.Status.NOT_FOUND) .addMessage("Unable to find a puzzle with that ID.") .build(); } String cellsJson = puzzle.getCellsJson(); boolean complete = cellsJson.equals(body.get("cells")); if (complete && ctx.getUserPrincipal() != null) { try { Long userId = Long.valueOf(ctx.getUserPrincipal().getName()); User user = User.getUser(userId); if (user != null && !user.getCompletedPuzzleIds().contains(id)) { user.getCompletedPuzzleIds().add(id); user.persist(); } } catch (Exception e) { // Optional: log the error if something fails, but no crash } } return new ResponseBody(Response.Status.OK) .addMessage(complete ? "It's a match! Puzzle completed." : "Try again </3. Puzzle did not match.") .addObject("complete", complete) .build(); } /** * @param id - The id of the puzzle * @param ctx - The context * @return A boolean that's true if the authorized user is the creator of the puzzle, or is an admin. */ private static boolean hasFullAccess(Long id, SecurityContext ctx) { if (ctx.getUserPrincipal() == null) return false; Puzzle puzzle = Puzzle.find("id", id).firstResult(); String creatorID = puzzle.getCreator().getID().toString(); if (ctx.getUserPrincipal().getName().equals(creatorID)) return true; if (ctx.isUserInRole("ADMIN")) return true; return false; } /** * Likes a puzzle on behalf of the authenticated user. * @param puzzleId The ID of the puzzle to like. * @param ctx The security context containing the authenticated user. * @return HTTP 200 if successful, or HTTP 404 if the puzzle or user is not found. */ @POST @Path("/{puzzleId}/like") @RolesAllowed({"USER"}) @Transactional public Response likePuzzle(@PathParam("puzzleId") Long puzzleId, @Context SecurityContext ctx) { Long userId = Long.valueOf(ctx.getUserPrincipal().getName()); User user = User.getUser(userId); Puzzle puzzle = Puzzle.findById(puzzleId); if (puzzle == null || user == null) { return Response.status(Response.Status.NOT_FOUND).entity("Puzzle or user not found").build(); } if (!user.getLikedPuzzleIds().contains(puzzleId)) { user.getLikedPuzzleIds().add(puzzleId); puzzle.incrementLikeCount(); } user.persist(); puzzle.persist(); return Response.ok().entity("Puzzle liked successfully").build(); } /** * Unlikes a puzzle on behalf of the authenticated user. * * @param puzzleId The ID of the puzzle to unlike. * @param ctx The security context containing the authenticated user. * @return HTTP 200 if successful, or HTTP 404 if the puzzle or user is not found. */ @POST @Path("/{puzzleId}/unlike") @RolesAllowed({"USER"}) @Transactional public Response unlikePuzzle(@PathParam("puzzleId") Long puzzleId, @Context SecurityContext ctx) { Long userId = Long.valueOf(ctx.getUserPrincipal().getName()); User user = User.getUser(userId); Puzzle puzzle = Puzzle.findById(puzzleId); if (puzzle == null || user == null) { return Response.status(Response.Status.NOT_FOUND).entity("Puzzle or user not found").build(); } if (user.getLikedPuzzleIds().remove(puzzleId)) { puzzle.decrementLikeCount(); } user.persist(); puzzle.persist(); return Response.ok().entity("Puzzle unliked successfully").build(); } /** * Favorites a puzzle on behalf of the authenticated user. * * @param puzzleId The ID of the puzzle to favorite. * @param ctx The security context containing the authenticated user. * @return HTTP 200 if successful, or HTTP 404 if the puzzle or user is not found. */ @POST @Path("/{puzzleId}/favorite") @RolesAllowed({"USER"}) @Transactional public Response favoritePuzzle(@PathParam("puzzleId") Long puzzleId, @Context SecurityContext ctx) { Long userId = Long.valueOf(ctx.getUserPrincipal().getName()); User user = User.getUser(userId); Puzzle puzzle = Puzzle.findById(puzzleId); if (puzzle == null || user == null) { return Response.status(Response.Status.NOT_FOUND).entity("Puzzle or user not found").build(); } if (!user.getFavoritedPuzzleIds().contains(puzzleId)) { user.getFavoritedPuzzleIds().add(puzzleId); puzzle.incrementFavoriteCount(); } user.persist(); puzzle.persist(); return Response.ok().entity("Puzzle favorited successfully").build(); } /** * Removes a puzzle from the authenticated user's favorites. * * @param puzzleId The ID of the puzzle to unfavorite. * @param ctx The security context containing the authenticated user. * @return HTTP 200 if successful, or HTTP 404 if the puzzle or user is not found. */ @POST @Path("/{puzzleId}/unfavorite") @RolesAllowed({"USER"}) @Transactional public Response unfavoritePuzzle(@PathParam("puzzleId") Long puzzleId, @Context SecurityContext ctx) { Long userId = Long.valueOf(ctx.getUserPrincipal().getName()); User user = User.getUser(userId); Puzzle puzzle = Puzzle.findById(puzzleId); if (puzzle == null || user == null) { return Response.status(Response.Status.NOT_FOUND).entity("Puzzle or user not found").build(); } if (user.getFavoritedPuzzleIds().remove(puzzleId)) { puzzle.decrementFavoriteCount(); } user.persist(); puzzle.persist(); return Response.ok().entity("Puzzle unfavorited successfully").build(); } }
